<html>

<head>
    <title>SpaceGame</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <script>
        window.onload = function () {
            var context = new AudioContext();
        }
    </script>
</head>

<body>
    <iframe allow="autoplay" id="audio" style="display:none"></iframe>
    <audio autoplay loop id="playAudio">
        <source src="audio.ogg">
    </audio>
    <script src="three.js"></script>
    <script src="THREEx.KeyboardState.js"></script>
    <script src="GLTFLoader.js"></script>
    <script>
        alert("Zdobądź jak najwięcej punktów, unikaj komet, zbieraj diamenty i serduszka. Sterowanie A-lewo D-prawo.")
        var renderer;
        var scene;
        var camera;
        //var keyboard = new THREEx.KeyboardState();
        var ship; // model statku
        var positionLimit = 13; // zakres ruchu w prawo/lewo
        var shipSpeed = 0.2; // predkosc statku
        var bullets = []; // tablica przechowywujaca pociski
        var target; // wektor gdzie ma swiecic swiatlo  
        var cometSpeed = 0.01; // predkosc komet
        var collidableMeshList = []; // tablica na komety
        var heartMeshList = []; // tablica przechowywujaca serduszka
        var heartInterface = [3] // tablica na 3 życia
        var numberOfHearts = 3 // startowa liczba żyć
        var heart1, heart2, heart3; // interfejs serc 
        var comet; // kometa
        var gameOver; // przechowuje napis gameover
        var scoreText; // przechowuje tekst wyniku na koniec
        var gameOverTrue = 0; // detekcja kolizji  dodatkowy warunek 
        var score = -2; // zmienna przechowujaca wynik
        var countAlive = 0; // zmienna sprawdzajaca czy licznik juz istnieje pomagajaca przy tworzeniu kolejnych obiektow cyfr
        var intervalCounter; //zmienna bedaca funkcja interwalowa podczas game over pozwala zatrzymac licznik
        var immortality = 0; // wartosc pomocnicza pomagajaca poprawic jakosc kolizji
        var diamondsList = []; // przechowuje diamenciki
        var diamondTaken = 0; // wartosc pomocnicza poprawiajaca kolizje diamentow
        var isLoaded = 0; // zmienna 0 - model niezaladowany 1 - model zaladowany
        var redColisionLight; // po uderzeniu w komete statek zapala sie na czerwono
        //var shotAvaible = 0;
        //var bullet;


        var superPoints = [];
        var darkModeStatus = 0;
        var globalLight;
        var shipLight;
        var box;
        var model;

        init();
        animate();

        function init() {

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.shadowMap.enabled = true; // mowimy rendererowi ze beda cienie
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);
            camera.position.z = 10;
            camera.position.y = 6;

            var geometry = new THREE.BoxGeometry(3.4, 0.5, 1);
            var material = new THREE.MeshBasicMaterial({ color: 0x444444, colorWrite: 0 });
            box = new THREE.Mesh(geometry, material);
            box.position.z -= 2;
            box.position.y -= 0.5;
            box.receiveShadow = true;
            scene.add(box);



            var loader = new THREE.GLTFLoader();
            loader.load('SpaceShip.glb', handle_load);

            function handle_load(gltf) {

                ship = gltf.scene.children[0]
                ship.scale.set(0.5, 0.5, 0.5);
                scene.add(ship);
                ship.position.set(0, 0, -2);
                setTimeout(isLoadedOn, 1000);

            }


            // Zmiana trybu oswietlenia
            darkMode();
            standardMode();

            var x = 0, y = -50;
            var heartShape = new THREE.Shape()
            heartShape.moveTo(25, 25)
            heartShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
            heartShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
            heartShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
            heartShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
            heartShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
            heartShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);
            var extrudeSettings = { depth: 10, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 15, bevelThickness: 15 };
            var geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            heart1 = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            heart1.receiveShadow = true;
            heart1.rotation.z = Math.PI / 0.85;
            //heart.rotation.y = Math.PI/14;
            heart1.scale.set(0.005, 0.005, 0.005);
            heart1.position.set(-10.5, 12.6, -1)
            scene.add(heart1)

            heart2 = heart1.clone();
            heart2.position.x += 1;
            scene.add(heart2);

            heart3 = heart1.clone();
            heart3.position.x += 2;
            scene.add(heart3);

            // heartInterface.push(heart1, heart2, heart3);



            livesText();
            intervalCounter = setInterval(counterStart, 500);
            bcgCreate(); // czerwone asteroidy w tle 
            setInterval(generateComets, 120);
            setInterval(generateHearts, 10000);
            setInterval(generateDiamonds, 1900)
        }


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function animate() {
            requestAnimationFrame(animate);
            if (isLoaded == 1) {
                if (darkModeStatus == 1) {
                    shipLight.position.set(ship.position.x, ship.position.y, ship.position.z); // zmiana pozycji swiatla
                    shipLight.target.position.set(ship.position.x, ship.position.y, -10); // zmiana wektora wg którego swieci
                }
                bcgMovement();
                cometsMovement();
                heartsMovement();
                diamondsMovement()
                //bulletsMovement();
                colisionDetector();
                heartColisionDetector()
                diamondsColisionDetector()
                //if (shotAvaible==1) bulletColisionDetector()
                keyboardControl();
            }
            else {

            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function () {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // STANDARDOWY TRYB OSWIETLENIA //////////////////////////////////////////////////////////////////////////////////////////////////////
        function standardMode() {
            globalLight = new THREE.PointLight(0xffffff, 0.95, 180); //0,8 30
            globalLight.position.set(0, 5, 10);
            globalLight.castShadow = true;
            globalLight.shadow.camera.near = 0.01;
            globalLight.shadow.camera.far = 500;
            scene.add(globalLight);

            redColisionLight = new THREE.PointLight(0xff0000, 1.5, 180); //0,8 30
            redColisionLight.position.set(0, 5, 10);
            redColisionLight.castShadow = true;
            redColisionLight.shadow.camera.near = 0.01;
            redColisionLight.shadow.camera.far = 10;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // tryb latarki ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function darkMode() {
            darkModeStatus = 1;

            globalLight = new THREE.PointLight(0xffffff, 0.8, 30); //0,8 30
            globalLight.position.set(0, 5, 10);
            globalLight.castShadow = true;
            globalLight.shadow.camera.near = 0.01;
            globalLight.shadow.camera.far = 500;
            scene.add(globalLight);

            var intensity = 0.4;
            var color = 0xffffff;
            var angle = Math.PI / 8;
            var distance = 150;
            var prenumbra = 0.5;
            shipLight = new THREE.SpotLight(color, intensity, distance, angle, prenumbra);
            shipLight.position.set(0, 0, -3);
            shipLight.target.position.set(0, 0, -10);
            scene.add(shipLight);
            scene.add(shipLight.target);
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // LICZNIK ODLICZAJACY PUNKTY ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function counterStart() {
            if (countAlive != 0) scene.remove(count);
            delete (count);

            var text;
            if (score == -2) text = "READY";
            else if (score == -1) text = "STEADY";
            else if (score == 0) text = "GO!";
            else text = score;


            var loader = new THREE.FontLoader();
            loader.load('Consolas.json', function (font) {
                var geometry = new THREE.TextGeometry(String(text), {
                    font: font,
                    size: 1.0,
                    height: 0.1,


                });
                geometry.center();
                var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                count = new THREE.Mesh(geometry, material);
                scene.add(count);
                count.position.z = -5;
                count.position.y = 15;
                countAlive = 1;

                // mesh.rotation.x = Math.PI/2;
            });
            score++;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // TWORZENIE TLA ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function bcgCreate() {
            starGeo = new THREE.Geometry();
            for (let i = 0; i < 1000; i++) {
                var star = new THREE.Vector3(
                    Math.random() * 900 - 450,
                    Math.random() * 900 - 450,
                    Math.random() * 2000 - 1000
                );

                star.velocity = 0; // predkosc wirowania
                star.acceleration = cometSpeed; // okresla przyspieszenie
                starGeo.vertices.push(star);
            }

            let sprite = new THREE.TextureLoader().load('star.png');
            let starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                map: sprite
            });
            stars = new THREE.Points(starGeo, starMaterial);
            scene.add(stars);
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // RUCH TŁA /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function bcgMovement() {
            starGeo.vertices.forEach(p => {
                p.velocity += p.acceleration;
                p.z += p.velocity;
                if (p.z > 0) {
                    p.z = -200; // odleglosc z jakiej nadlatuja
                    p.velocity = 0; // trzeba tutaj zerować bo tak to będzie przyspieszać w nieskonczonosc
                }
            });
            //starGeo.acceleration = 1;
            starGeo.verticesNeedUpdate = true; // uruchamia ruch w glab
            //stars.rotation.y += 0.002;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // FUNKCJA ODPOWIEDZIALNA ZA RUCH POCISKU //////////////////////////////////////////////////////////////////////////////////////////////////////
        // function bulletsMovement()
        // {
        //     for (var i=0; i<bullets.length; i++)
        //     {
        //         if(bullets[i] === undefined) continue;
        //             if(bullets[i].alive == false)
        //             {
        //                 bullets.splice(i,1); // na pozycji i usun 1 item
        //                 continue;
        //             }
        //             bullets[i].position.add(bullets[i].velocity);
        //     }
        // }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // FUNKCJA GENERUJACA SERDUSZKA /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function generateHearts() {
            var x = 0, y = -50;
            var heartShape = new THREE.Shape()
            heartShape.moveTo(25, 25)
            heartShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
            heartShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
            heartShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
            heartShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
            heartShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
            heartShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);
            var extrudeSettings = { depth: 10, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 15, bevelThickness: 15 };
            var geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            var heart = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            heart.receiveShadow = true;
            heart.rotation.z = Math.PI;
            heart.scale.set(0.05, 0.05, 0.05);
            heart.position.set(Math.random() * 4 + 1, Math.random() * 4 + 1, 1);
            heart.position.y += 15;
            //scene.add(mesh);


            //  var heart = new THREE.Mesh(
            //      new THREE.SphereGeometry(Math.random()*4+1,Math.random()*4+1,1),
            //      new THREE.MeshBasicMaterial({color: Math.random()*0xffffff})
            //      );
            //comet.receiveShadow = true;
            heart.position.set(40 * Math.random() - 20, 0, -300);

            heart.velocity = new THREE.Vector3(0.2 * (Math.random()) - 0.1, 0, 0.6); // predkosc komety

            heart.alive = true;
            setTimeout(
                function () {
                    heart.alive = false; // wylaczenie = leca w nieskonczonosc
                    heart.remove(heart); // 
                }
                , 6000); // czas lotu po ktorym zniknie
            heartMeshList.push(heart);
            scene.add(heart);
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // RUCH SERDUSZEK //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function heartsMovement() {
            for (var i = 0; i < heartMeshList.length; i++) {
                if (heartMeshList[i] === undefined) continue;
                if (heartMeshList[i].alive == false) {
                    heartMeshList.splice(i, 1); // na pozycji i usun 1 item
                    continue;
                }
                heartMeshList[i].position.add(heartMeshList[i].velocity);
            }
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // FUNKCJA GENERUJACA LECACE KOMETY /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function generateComets() {
            var comet = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random() * 4 + 1, Math.random() * 4 + 1, 1),

                new THREE.MeshStandardMaterial({ color: 0x123456 })
            );
            comet.receiveShadow = true;
            comet.position.set(40 * Math.random() - 20, 0, -300);

            comet.velocity = new THREE.Vector3(0.2 * (Math.random()) - 0.1, 0, 0.6); // predkosc komety

            comet.alive = true;
            setTimeout(
                function () {
                    comet.alive = false; // wylaczenie = leca w nieskonczonosc
                    scene.remove(comet); // 
                }
                , 6000); // czas lotu po ktorym zniknie
            collidableMeshList.push(comet);
            scene.add(comet);
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // RUCH KOMET //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function cometsMovement() {
            for (var i = 0; i < collidableMeshList.length; i++) {
                if (collidableMeshList[i] === undefined) continue;
                if (collidableMeshList[i].alive == false) {
                    collidableMeshList.splice(i, 1); // na pozycji i usun 1 item
                    continue;
                }
                collidableMeshList[i].position.add(collidableMeshList[i].velocity);
            }
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // FUNKCJA GENERUJACA DIAMENCIKI /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function generateDiamonds() {
            var diamond = new THREE.Mesh(
                new THREE.OctahedronBufferGeometry(1.5),
                new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 1, roughness: 0.7 })
            );
            diamond.receiveShadow = true;
            diamond.position.set(40 * Math.random() - 20, 0, -300);

            diamond.velocity = new THREE.Vector3(0.2 * (Math.random()) - 0.1, 0, 0.6); // predkosc komety

            diamond.alive = true;
            setTimeout(
                function () {
                    diamond.alive = false; // wylaczenie = leca w nieskonczonosc
                    diamond.remove(comet); // 
                }
                , 6000); // czas lotu po ktorym zniknie
            diamondsList.push(diamond);
            scene.add(diamond);
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // RUCH DIAMENTOW //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function diamondsMovement() {
            for (var i = 0; i < diamondsList.length; i++) {
                if (diamondsList[i] === undefined) continue;
                if (diamondsList[i].alive == false) {
                    diamondsList.splice(i, 1); // na pozycji i usun 1 item
                    continue;
                }
                diamondsList[i].position.add(diamondsList[i].velocity);
            }
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        // FUNKCJA ODPOWIEDZIALNA ZA STEROWANIE OBIEKTEM W PRAWO I W LEWO AŻ DO OKRESLONEJ POZYCJI PRZEZ positionLimit ORAZ STRZELANIE    ////////////////
        function keyboardControl() {
            var actualPosition = ship.position.x;
            if (actualPosition < positionLimit) {
                if (keyboard.pressed("D")) {

                    ship.position.x += shipSpeed;
                    box.position.x += shipSpeed;
                }
                else ship.rotation.z = 0, box.rotation.z = 0; // ten warunek obsluguje zatrzymanie poruszania w srodku
            }
            else ship.rotation.z = 0, box.rotation.z = 0;

            if (actualPosition > -positionLimit) {
                if (keyboard.pressed("A")) {
                    ship.position.x -= shipSpeed;
                    box.position.x -= shipSpeed;
                }
            }
            else ship.rotation.z = 0;

            if (keyboard.pressed("A")) ship.rotation.z = Math.PI / 8, box.rotation.z = Math.PI / 8; // PRZECHYLENIE STATKU NA BOK
            if (keyboard.pressed("D")) ship.rotation.z = -Math.PI / 8, box.rotation.z = -Math.PI / 8; // PRZECHYLENIE STATKU NA BOK



            document.onkeydown = function (e) // onkeydown wlacza funkcje 
            {
                e = e || window.event;
                switch (e.keyCode) {
                    // case 32: singleShot(); break;
                    case 13: if (gameOverTrue == 1) restart(); brake;
                    default: ;
                }
            }

        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        //  FUNKCJA GENERUJACA POJEDNCZE POCISKI KTORE DODAWANE SA DO GLOBALNEJ TABLICY   /////////////////////////////////////////////////////////////////////
        // function singleShot()
        // {
        //     if (shotAvaible==0)
        //     {
        //         bullet = new THREE.Mesh(
        //         new THREE.SphereGeometry(0.9,8,8),
        //         new THREE.MeshBasicMaterial({color: Math.random()*0x00ff00})
        //         );

        //         bullet.position.set( // pozycja poczatkowa pocisku ustalana na podstawie aktualnej pozycji statku
        //              ship.position.x,
        //              ship.position.y,
        //              ship.position.z,
        //         );

        //          bullet.velocity = new THREE.Vector3(
        //              0,0,-0.5 // predkosc pocisku
        //              //Math.sin(camera.rotation.y),0,Math.cos(camera.rotation.y) // podazanie za kamera dla nas not usefull
        //          );

        //         bullet.alive = true;
        //         setTimeout(
        //             function()
        //             {
        //                 bullet.alive = false; // wylaczenie = leca w nieskonczonosc
        //                 scene.remove(bullet); // 
        //             }
        //             ,2000); // czas lotu po ktorym zniknie
        //         bullets.push(bullet);
        //         scene.add(bullet);
        //         shotAvaible=1;

        //         setTimeout(shotAvaibleOn,5000)
        //     }
        // }


        // function shotAvaibleOn(){
        //     shotAvaible=0;
        // }


        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




        // FUNKCJA BEDACA DETEKTOREM KOLIZJI KOMET //////////////////////////////////////////////////////////////////////////////////

        // określa, czy którykolwiek z promieni od początku sześcianu do każdego wierzchołka
        // przecina dowolną powierzchnię siatki w szeregu siatek docelowych
        // dla zwiększenia dokładności kolizji dodaj więcej wierzchołków do sześcianu;
        // gdy źródło promienia znajduje się w docelowej siatce, kolizje nie występują

        function colisionDetector() {
            for (var i = 0; i < collidableMeshList.length; i++) {
                var originPoint = box.position.clone();

                for (var vertexIndex = 0; vertexIndex < box.geometry.vertices.length; vertexIndex++) {
                    var localVertex = box.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(box.matrix);
                    var directionVector = globalVertex.sub(box.position); // wektro kierunkowy = globalny vektor - pozycja statku

                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize()); // skad promien jest rzucany, jego kierunek
                    var collisionResults = ray.intersectObjects(collidableMeshList);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())  // jesli zaszla kolizja
                    {

                        console.log(numberOfHearts)
                        if (numberOfHearts == 3 && immortality == 0) {


                            numberOfHearts = 2;
                            scene.remove(collidableMeshList[i]);
                            collidableMeshList.splice(i, 1);
                            scene.remove(heart3);
                            immortality = 1;
                            setTimeout(immortalityOff, 100)
                            redLightOn()

                            return;
                        }
                        else if (numberOfHearts == 2 && immortality == 0) {

                            numberOfHearts = 1;
                            scene.remove(collidableMeshList[i]);
                            collidableMeshList.splice(i, 1);
                            scene.remove(heart2);
                            immortality = 1;
                            setTimeout(immortalityOff, 100)
                            redLightOn()
                            return;

                        }
                        else if (numberOfHearts == 1 && immortality == 0) {


                            numberOfHearts = 0;
                            scene.remove(collidableMeshList[i]);
                            collidableMeshList.splice(i, 1);
                            scene.remove(heart1);



                            scene.remove(collidableMeshList[i]);
                            collidableMeshList.splice(i, 1);
                            scene.remove(ship);
                            if (gameOverTrue == 0) gameOverFont(), gameOverTrue++;
                            clearInterval(intervalCounter);

                            return;
                        }
                    }
                }
            }
        }




        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // FUNKCJA BEDACA DETEKTOREM KOLIZJI dla serduszek //////////////////////////////////////////////////////////////////////////////////

        function heartColisionDetector() {
            for (var i = 0; i < heartMeshList.length; i++) {
                var originPoint = box.position.clone();

                for (var vertexIndex = 0; vertexIndex < box.geometry.vertices.length; vertexIndex++) {
                    var localVertex = box.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(box.matrix);
                    var directionVector = globalVertex.sub(box.position);

                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(heartMeshList);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())  // jesli zaszla kolizja
                    {
                        scene.remove(heartMeshList[i]);
                        heartMeshList.splice(i, 1);
                        //score+=50;  
                        if (numberOfHearts == 3) {
                            return 0;
                        }
                        else if (numberOfHearts == 2) {
                            numberOfHearts = 3;
                            scene.add(heart3);
                            return 0;
                        }
                        else if (numberOfHearts == 1) {
                            numberOfHearts = 2
                            scene.add(heart2);
                            return 0;
                        }
                        return 0;
                    }
                }
            }
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // FUNKCJA BEDACA DETEKTOREM KOLIZJI dla diamentow dodaje + 50pkt //////////////////////////////////////////////////////////////////////////////////

        function diamondsColisionDetector() {
            for (var i = 0; i < diamondsList.length; i++) {
                var originPoint = box.position.clone();

                for (var vertexIndex = 0; vertexIndex < box.geometry.vertices.length; vertexIndex++) {
                    var localVertex = box.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(box.matrix);
                    var directionVector = globalVertex.sub(ship.position);

                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                    var collisionResults = ray.intersectObjects(diamondsList);
                    if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() && diamondTaken == 0)  // jesli zaszla kolizja
                    {

                        scene.remove(diamondsList[i]);
                        diamondsList.splice(i, 1);
                        score += 50;
                        diamondTaken = 1;
                        setTimeout(diamondTakenOff, 100)

                        return 0;
                    }
                }
            }
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // koniec gry napis ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function gameOverFont() {
            var loader = new THREE.FontLoader();
            loader.load('Consolas.json', function (font) {
                var geometry = new THREE.TextGeometry("GAME OVER", {
                    font: font,
                    size: 2.6,
                    height: 0.01,

                });
                geometry.center();
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                gameOver = new THREE.Mesh(geometry, material);
                scene.add(gameOver);
                gameOver.position.z = -5;
                gameOver.position.y = 6;

                var geometry2 = new THREE.TextGeometry("Your score:" + (score - 1), {
                    font: font,
                    size: 1.0,
                    height: 0.01,

                });
                geometry2.center();
                scoreText = new THREE.Mesh(geometry2, material);
                scene.add(scoreText);
                scoreText.position.z = -5;
                scoreText.position.y = 4;


                var geometry3 = new THREE.TextGeometry("Press ENTER to play again", {
                    font: font,
                    size: 1.0,
                    height: 0.01,


                });
                geometry3.center();
                againText = new THREE.Mesh(geometry3, material);
                scene.add(againText);
                againText.position.z = -5;
                againText.position.y = 2.4;
            });
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // NAPIS ŻYCIE ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function livesText() {

            var loader = new THREE.FontLoader();
            loader.load('Consolas.json', function (font) {
                var geometry = new THREE.TextGeometry(String("LIVES: "), {
                    font: font,
                    size: 1.0,
                    height: 0.1,
                    curveSegments: 2,

                });
                geometry.center();
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var lives = new THREE.Mesh(geometry, material);
                scene.add(lives);
                lives.position.z = -5;
                lives.position.y = 15;
                lives.position.x = -18;


            });

        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function restart() {
            for (var i = 0; i < collidableMeshList.length; i++) {
                scene.remove(collidableMeshList[i]);
                //collidableMeshList.splice(i,1);
            }
            for (var i = 0; i < heartMeshList.length; i++) {
                scene.remove(heartMeshList[i]);
                //collidableMeshList.splice(i,1);
            }
            for (var i = 0; i < diamondsList.length; i++) {
                scene.remove(diamondsList[i]);
                //collidableMeshList.splice(i,1);
            }

            numberOfHearts = 3;
            gameOverTrue = 0
            diamondTaken = 0;
            scene.add(heart1, heart2, heart3)
            ship.position.x = 0;
            box.position.x = 0;
            scene.add(ship);
            score = -2;
            scene.remove(gameOver);
            scene.remove(scoreText);
            scene.remove(againText)
            clearInterval(intervalCounter);
            intervalCounter = setInterval(counterStart, 500);
        }

        function immortalityOn() {
            immortality = 1;
        }
        function immortalityOff() {
            immortality = 0;
        }

        function diamondTakenOff() {
            diamondTaken = 0;
        }

        function isLoadedOn() {
            isLoaded = 1;
        }
        function redLightOn() {
            scene.add(redColisionLight);
            setTimeout(redLightOff, 300)
        }
        function redLightOff() {
            scene.remove(redColisionLight);
        }



        animate();
    </script>
</body>

</html>